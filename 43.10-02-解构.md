在 ES6 中，你可以使用_解构_从数组和对象中提取值并赋给独特的变量。

听起来好像你之前就这么做过，例如，看看下面的两个代码段，它们使用 ES6 之前的技巧提取数据：

```js
const point = [10, 25, -34];

const x = point[0];
const y = point[1];
const z = point[2];

console.log(x, y, z);
```

> **Prints:** 10 25 -34

上述示例显示了从数组中提取值的过程。

```js
const gemstone = {
  type: 'quartz',
  color: 'rose',
  karat: 21.29
};

const type = gemstone.type;
const color = gemstone.color;
const karat = gemstone.karat;

console.log(type, color, karat);
```

> **Prints:** quartz rose 21.29

该示例显示了从对象中提取值的过程。

二者都很简单，但是这两个示例都没用到解构。

那么_解构_到底是什么？

## 解构

**解构**这一概念从 [Perl](https://baike.baidu.com/item/perl/851577?fr=aladdin) 和 [Python](https://baike.baidu.com/item/Python/407313) 等语言中获得灵感，使你能够指定要从赋值左侧上的数组或对象中提取的元素。听起来有点奇怪，实际上可以获得和之前一样的结果，但是用到的代码确更少；依然很好理解。

我们看看这两个示例使用解构编写后的效果。

### 解构数组中的值

```js
const point = [10, 25, -34];

const [x, y, z] = point;

console.log(x, y, z);
```

> **Prints:** 10 25 -34

在此示例中，方括号 `[ ]` 表示被解构的数组，`x`、`y` 和 `z` 表示要将数组中的值存储在其中的变量。注意，你不需要指定要从中提取值的索引，因为索引可以暗示出来。

> **提示：**在解构数组时，还可以忽略值。例如，`const [x, , z] = point;` 忽略了 `y` 坐标。



### 习题 1/2

你认为在运行以下代码后，`second` 的值是多少？

```js
let positions = ['Gabrielle', 'Jarrod', 'Kate', 'Fernando', 'Mike', 'Walter'];
let [first, second, third] = positions;
```

- Kate
- Gabrielle
- Jarrod
- Walter

提交



### 解构对象中的值

```js
const gemstone = {
  type: 'quartz',
  color: 'rose',
  karat: 21.29
};

const {type, color, karat} = gemstone;

console.log(type, color, karat);
```

> **Prints:** quartz rose 21.29

在此示例中，花括号 `{ }` 表示被解构的对象，`type`、`color` 和 `karat` 表示要将对象中的属性存储到其中的变量。注意不用指定要从其中提取值的属性。因为 `gemstone` 具有 `type` 属性，值自动存储在 `type`变量中。类似地，`gemstone` 具有 `color` 属性，因此 `color` 的值自动存储在 `color` 变量中。`karat`也一样。

> **提示：**你还可以指定在解构对象时要选择的值。例如，`let {color} = gemstone;` 将仅选择 `gemstone` 对象中的 `color` 属性。