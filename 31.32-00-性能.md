**本章指出一些常见的 JavaScript 错误。**

## 意外使用赋值运算符

如果程序员在 if 语句中意外使用赋值运算符（=）而不是比较运算符（===），JavaScript 程序可能会产生一些无法预料的结果。

这条 if 语句返回 false（正如预期），因为 x 不等于 10：

```
var x = 0;
if (x == 10) 
```

[亲自试一试](https://www.w3school.com.cn/tiy/t.asp?f=js_mistakes_equal_1)

这条 if 语句返回 true（也许不像预期），因为 10 为 true：

```
var x = 0;
if (x = 10) 
```

[亲自试一试](https://www.w3school.com.cn/tiy/t.asp?f=js_mistakes_equal_2)

这条 if 语句返回 false（也许不像预期），因为 0 为 false：

```
var x = 0;
if (x = 0) 
```

[亲自试一试](https://www.w3school.com.cn/tiy/t.asp?f=js_mistakes_equal_3)

赋值总是返回赋值的值。

## 期望松散的比较

在常规比较中，数据类型不重要。这条 if 语句返回 true：

```
var x = 10;
var y = "10";
if (x == y) 
```

[亲自试一试](https://www.w3school.com.cn/tiy/t.asp?f=js_mistakes_loose_comparison_1)

在严格比较中，数据类型确实重要。这条 if 语句返回 false：

```
var x = 10;
var y = "10";
if (x === y) 
```

[亲自试一试](https://www.w3school.com.cn/tiy/t.asp?f=js_mistakes_loose_comparison_2)

有一个常见的错误是忘记在 switch 语句中使用严格比较：

这条 switch 语句会显示提示框：

```
var x = 10;
switch(x) {
    case 10: alert("Hello");
}
```

[亲自试一试](https://www.w3school.com.cn/tiy/t.asp?f=js_mistakes_loose_comparison_3)

这条 switch 语句不会显示提示框：

```
var x = 10;
switch(x) {
    case "10": alert("Hello");
}
```

[亲自试一试](https://www.w3school.com.cn/tiy/t.asp?f=js_mistakes_loose_comparison_4)

## 令人困惑的加法和级联

*加法*用于加*数值*。

*级联（Concatenation）*用于加*字符串*。

在 JavaScript 中，这两种运算均使用相同的 + 运算符。

正因如此，将数字作为数值相加，与将数字作为字符串相加，将产生不同的结果：

```
var x = 10 + 5;          // x 中的结果是 15
var x = 10 + "5";         // x 中的结果是　"105"
```

[亲自试一试](https://www.w3school.com.cn/tiy/t.asp?f=js_mistakes_add_1)

如果是两个变量相加，很难预测结果：

```
var x = 10;
var y = 5;
var z = x + y;            // z 中的结果是 15

var x = 10;
var y = "5";
var z =  x + y;            // z 中的结果是 "105"
```

[亲自试一试](https://www.w3school.com.cn/tiy/t.asp?f=js_mistakes_add_2)

## 令人误解的浮点

JavaScript 中的数字均保存为 64 位的*浮点数（Floats）*。

所有编程语言，包括 JavaScript，都存在处理浮点值的困难：

```
var x = 0.1;
var y = 0.2;
var z = x + y             // z 中的结果并不是 0.3
```

[亲自试一试](https://www.w3school.com.cn/tiy/t.asp?f=js_mistakes_floats)

为了解决上面的问题，请使用乘除运算：

### 实例

```
var z = (x * 10 + y * 10) / 10;       // z 中的结果将是 0.3
```

[亲自试一试](https://www.w3school.com.cn/tiy/t.asp?f=js_mistakes_floats_ok)

## 对 JavaScript 字符串换行

JavaScript 允许您把一条语句换行为两行：

### 例子 1

```
var x =
"Hello World!";
```

[亲自试一试](https://www.w3school.com.cn/tiy/t.asp?f=js_mistakes_breaking_string_1)

但是，在字符串中间来换行是不对的：

### 例子 2

```
var x = "Hello
World!";
```

[亲自试一试](https://www.w3school.com.cn/tiy/t.asp?f=js_mistakes_breaking_string_2)

如果必须在字符串中换行，则必须使用反斜杠：

### 例子 3

```
var x = "Hello \
World!";
```

[亲自试一试](https://www.w3school.com.cn/tiy/t.asp?f=js_mistakes_breaking_string_3)

## 错位的分号

因为一个错误的分号，此代码块无论 x 的值如何都会执行：

```
if (x == 19);
{
     // code block
}
```

[亲自试一试](https://www.w3school.com.cn/tiy/t.asp?f=js_mistakes_semicolon)

## 对 return 语句进行换行

在一行的结尾自动关闭语句是默认的 JavaScript 行为。

正因如此，下面两个例子返回相同的结果：

### 例子 1

```
function myFunction(a) {
    var power = 10  
    return a * power
}
```

[亲自试一试](https://www.w3school.com.cn/tiy/t.asp?f=js_mistakes_return_1)

### 例子 2

```
function myFunction(a) {
    var power = 10;
    return a * power;
}
```

[亲自试一试](https://www.w3school.com.cn/tiy/t.asp?f=js_mistakes_return_2)

JavaScript 也允许您将一条语句换行为两行。

正因如此，例子 3 也将返回相同的结果：

### 例子 3

```
function myFunction(a) {
    var
    power = 10;  
    return a * power;
}
```

[亲自试一试](https://www.w3school.com.cn/tiy/t.asp?f=js_mistakes_return_3)

但是，如果把 return 语句换行为两行会发生什么呢：

### 例子 4

```
function myFunction(a) {
    var
    power = 10;  
    return
    a * power;
}
```

[亲自试一试](https://www.w3school.com.cn/tiy/t.asp?f=js_mistakes_return_4)

此函数将返回 undefined！

为什么呢？因为 JavaScript 认为你的意思是：

### 例子 5

```
function myFunction(a) {
     var
    power = 10;  
    return;
    a * power;
}
```

[亲自试一试](https://www.w3school.com.cn/tiy/t.asp?f=js_mistakes_return_5)

## 解释

如果某条语句是不完整的：

```
var
```

JavaScript 将通过读取下一行来完成这条语句：

```
power = 10;
```

但是由于这条语句是完整的：

```
return
```

JavaScript 会自动关闭该语句：

```
return;
```

发生这种情况是因为，在 JavaScript 中，用分号来关闭（结束）语句是可选的。

JavaScript 会在行末关闭 return 语句，因为它本身就是一条完整的语句。

所以，绝不要对 return 语句进行换行。

## 通过命名索引来访问数组

很多编程语言支持带有命名索引的数组。

带有命名索引的数组被称为关联数组（或散列）。

JavaScript *不支持*带有命名索引的数组。

在 JavaScript 中，*数组*使用*数字索引*：

### 实例

```
var person = [];
person[0] = "Bill";
person[1] = "Gates";
person[2] = 46;
var x = person.length;          // person.length 将返回 3
var y = person[0];              // person[0] 将返回 "John"
```

[亲自试一试](https://www.w3school.com.cn/tiy/t.asp?f=js_array_associative_1)

在 JavaScript 中，*对象*使用*命名索引*。

如果您使用命名索引，那么在访问数组时，JavaScript 会将数组重新定义为标准对象。

在自动重定义之后，数组方法或属性将产生未定义或非正确的结果：

### 实例

```
var person = [];
person["firstName"] = "Bill";
person["lastName"] = "Gates";
person["age"] = 46;
var x = person.length;         // person.length 将返回 0
var y = person[0];              // person[0] 将返回 undefined
```

[亲自试一试](https://www.w3school.com.cn/tiy/t.asp?f=js_array_associative_2)

## 用逗号来结束定义

对象和数组定义中的尾随逗号在 ECMAScript 5 中是合法的。

### 对象实例：

```
person = {firstName:"Bill", lastName:"Gates", age:62,}
```

### 数组实例：

```
points = [35, 450, 2, 7, 30, 16,];
```

### 警告！！

Internet Explorer 8 会崩溃。

JSON 不允许尾随逗号。

### JSON:

```
person = {firstName:"Bill", lastName:"Gates", age:62}
```

### JSON:

```
points = [35, 450, 2, 7, 30, 16];
```

## Undefined 不是 Null

JavaScript 对象、变量、属性和方法可以是未定义的。

此外，空的 JavaScript 对象的值可以为 null。

这可能会使测试对象是否为空变得有点困难。

您可以通过测试类型是否为 undefined，来测试对象是否存在：

### 实例

```
if (typeof myObj === "undefined")
```

[亲自试一试](https://www.w3school.com.cn/tiy/t.asp?f=js_mistakes_object_undefined)

但是您无法测试对象是否为 null，因为如果对象未定义，将抛出错误：

### 不正确的：

```
if (myObj === null)
```

要解决此问题，必须测试对象是否为 null，而不是未定义。

但这仍然会引发错误：

### 不正确的：

```
if (myObj !== null && typeof myObj !== "undefined")
```

因此，在测试非 null 之前，必须先测试未定义：

### 正确的：

if (typeof myObj !== "undefined" && myObj !== null)

[亲自试一试](https://www.w3school.com.cn/tiy/t.asp?f=js_mistakes_object_null)

## 期望块级范围

JavaScript *不会*为每个代码块创建新的作用域。

很多编程语言都是如此，但是 JavaScript *并非如此*。

认为这段代码会返回 undefined，是新的 JavaScript 开发者的常见错误：

### 实例

```
for (var i = 0; i < 10; i++) {
  // 代码块
}
return i;
```

[亲自试一试](https://www.w3school.com.cn/tiy/t.asp?f=js_mistakes_scope)