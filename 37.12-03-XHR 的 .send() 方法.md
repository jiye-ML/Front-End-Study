要实际地发送请求，我们需要使用 [send 方法](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/send)：

```js
asyncRequestObject.send();
```

我们来看看会发生什么：



[![img](https://video.udacity-data.com/topher/2017/August/59938614_ud109-l1-send-xhr-request-1/ud109-l1-send-xhr-request-1.gif)*XHR 请求被发送，但是我们没有看到任何内容！*](https://classroom.udacity.com/nanodegrees/nd001-cn-advanced/parts/b4672613-0d5a-4fb9-bb2d-571c92361fee/modules/3cc28649-e29e-4095-8dc9-d7943de84d87/lessons/8cb1042e-3260-469c-9f78-8e2f092a4725/concepts/0cd27aed-f95a-4148-ab61-c910b90d32a0#)



<video class="video__el" crossorigin="anonymous" style="box-sizing: inherit; width: 770px;"></video>



00:00 / 00:45



1x

CC







如果发出请求，然后什么也不做，则毫无意义。如果你订了蛋糕，但是没有去取或吃蛋糕，那还订干嘛？

### 处理成功的请求

要处理 XHR 请求的成功响应，我们将对象上的 [onload 属性](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestEventTarget/onload) 设为将处理它的函数：

```js
function handleSuccess() {
    // 在这个函数中，`this`值是 XHR 对象
    // this.responseText 保存来自服务器的响应

    console.log(this.responseText); // https://unsplash.com/ 的 HTML
}

asyncRequestObject.onload = handleSuccess;
```

正如我们所看到的，如果未设置 `onload`，则请求的确会返回，但是它什么也不会发生。



### 处理错误

你可能已经知道，如果请求成功，则调用 **onload**。如果请求出现问题，无法实现请求，则我们需要使用 **onerror 属性**：

```js
function handleError () {
    // 在这个函数中，`this` 值是 XHR 对象
    console.log( '出现错误 😞' );
}

asyncRequestObject.onerror = handleError;
```

和 `onload` 一样，如果 `onerror` 未设置，并且出现错误，则该错误将继续发生，但是没有任何提示，你的代码（以及用户）将不知道发生了什么问题，也不知道如何恢复。